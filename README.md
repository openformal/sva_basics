# Overview
This repository contains examples to illustrate the basics of **_System Verilog Assertions (SVAs)_** 
from the perspective of **_Formal Verification (FV)_**. These examples go over sequences, properties,
assertions, assumptions and covers. This is introductory material that covers basic principals.

The examples are in src directory and the associated documentation is in docs directory. The
documentation is autogenerated from the source using [markdown script in tools repository](https://github.com/openformal/tools/tree/master/markdown).

Some of the testbenches here use features of 2012 SystemVerilog. Tool support may not be uniform for these.

# Outline
* [Introduction](https://github.com/openformal/sva_basics/blob/master/testbench/docs/intro_tb.md)
* [Concurrent assertions](https://github.com/openformal/sva_basics/blob/master/testbench/docs/concurrent_assertions_tb.md)
* [Immediate assertions](https://github.com/openformal/sva_basics/blob/master/testbench/docs/immediate_assertions_tb.md)
* [Clocking](https://github.com/openformal/sva_basics/blob/master/testbench/docs/clocking_tb.md)
* [Module binding](https://github.com/openformal/sva_basics/blob/master/testbench/docs/bind_tb.md)
* [Formal arguments](https://github.com/openformal/sva_basics/blob/master/testbench/docs/arguments_tb.md)
* ["disable" keyword](https://github.com/openformal/sva_basics/blob/master/testbench/docs/disable_tb.md)
* [System functions](https://github.com/openformal/sva_basics/blob/master/testbench/docs/system_functions_tb.md)
* [Sampled value functions](https://github.com/openformal/sva_basics/blob/master/testbench/docs/sampled_value_functions_tb.md)
* [Delay operator](https://github.com/openformal/sva_basics/blob/master/testbench/docs/delay_operator_tb.md)
* [Consecutive repetition operator](https://github.com/openformal/sva_basics/blob/master/testbench/docs/cons_rep_operator_tb.md)
* [Goto and non consecutive repetition operator](https://github.com/openformal/sva_basics/blob/master/testbench/docs/goto_and_non_cons_rep_operator_tb.md)
* ["if" and "case" keywords](https://github.com/openformal/sva_basics/blob/master/testbench/docs/if_and_else_tb.md)
* [Local variables](https://github.com/openformal/sva_basics/blob/master/testbench/docs/local_variables_tb.md)
* [Sequence operators](https://github.com/openformal/sva_basics/blob/master/testbench/docs/sequence_operators_tb.md)
* [Property operators](https://github.com/openformal/sva_basics/blob/master/testbench/docs/property_operators_tb.md)
* [Safety vs Liveness](https://github.com/openformal/sva_basics/blob/master/testbench/docs/safety_vs_liveness_tb.md)

# General advise to the users
It is usually advisable to use constructs that match the use case. If multiple constructs can be used, the easiest to
understand is the best.

If the requirements involve a lot of correlated checking across interfaces and state, it is a good idea to craft a
synthesizable testbench that is self explanatory and write simpler assertions using the state and the outputs of
the state machine. In such scenarios, numerous interrealed but separate SVAs become hard to understand and debug.

# A caution against composing very complex sequences
There need to be some caution excercised when crafting very complicated sequences. It is advisable to make shorter sequences
and then use them to assemble larger sequences. Excessively complex sequences can be very hard do debug and often create overconstraints. Often their creator is the only one who can understands what they represent, and only on the day they get created. So maintanence is a problem with such sequences. These are akin to the regex contortions of the scripting world.
